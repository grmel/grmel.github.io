---
title: Все что надо знать о методах по умолчанию
categories:
 - Программирование
tags:
 - java
 - программирование
---

Статья представляет собой попытку собрать в одном месте информацию о методах по умолчанию, которая могла быть полезна как начинающим программистам, так и опытным. Мы начнем с базовых понятий и далее перейдем к более продвинутым темам: разрешение конфликтов, зачем нужны такие методы, в чем отличие интерфейсов с методами по умолчанию от абстрактных классов.

## Методы по умолчанию

Начиная с Java 8 появилась возможность объявлять в интерфейсах не только абстрактные методы, но и методы с конкретной реализацией.

### Синтаксис

Рассмотрим несколько упрощенную версию метода `Comparator.thenComparing(Comparator)` ([ссылка](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparing-java.util.Comparator-)) из JDK 8:

```java
default Comparator<T> thenComparing(Comparator<? super T> other) {
	return (o1, o2) -> {
		int res = this.compare(o1, o2);
		return (res != 0) ? res : other.compare(o1, o2);
	};
}
```

Объявление метода по умолчанию выглядит как объявление «обычного» метода, но в начало добавляется ключевое слово `default` и здесь же обязательно должна быть предоставлена реализация. Если хотя бы одно из вышеперечисленных условий не будет выполнено мы получим ошибку компиляции. Слово `default`, как мы увидим далее, намекает на определенные детали реализации [вызова таких методов](#вызов-методов-по-умолчанию).

Теперь каждый класс, реализующий интерфейс `Comparator`, содержит публичный метод `thenComparing(Comparator)` и при этом не обязан предоставлять свою реализацию этого метода.

### Явный вызов методов по умолчанию

В некоторых случаях может появиться необходимость явно вызвать метод по умолчанию реализуемого интерфейса в своем коде. Это можно сделать следующим образом:

```java
class StringComparator implements Comparator<String> {
 
	// ...
 
	@Override
	public Comparator<String> thenComparing(
			Comparator<? super String> other) {
		log("Call to 'thenComparing'.");
		return Comparator.super.thenComparing(other);
	}
}
```

Обратите внимание как имя интерфейса с ключевым словом `super` используется для доступа к методам интерфейса. Использование же `super` вместо `Comparator.super` будет указывать на родительский класс, т.е. `Object` в нашем случае. Синтаксис очень похож на [обращение к внешнему классу](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing) из внутреннего.

Невозможно вызвать метод интерфейса, который явно не указан в блоке `implements`. Например, если бы в нашем примере `StringComparator` наследовался от `ObjectComparator<T> extends Comparator<T>`, то вызов `Comparator.super.thenComparing` приводил бы к ошибке компиляции.

### Модификаторы

На методы по умолчанию наложено довольно много ограничений:
  * В Java 8 методы по умолчанию могут быть только публичными (как и «обычные» методы интерфейсов). Начиная с 9 версии могут быть и приватными.
  * Ключевое слово `synchronized` запрещено (как и для абстрактных методов).
  * Ключевое слово `final` запрещено (как и для абстрактных методов).

Естественно, все эти фичи были среди запрашиваемых и существует вполне ясное объяснение их отсутствия (как для [synchronized](https://stackoverflow.com/a/23463334/2525313), так и для [final](https://stackoverflow.com/a/23476994/2525313)). Аргументы в обоих случаях схожи: 1) это не то [для чего методы по умолчанию предназначались](#зачем-нужны-методы-по-умолчанию); 2) введение такого функционала приведет к усложнению и увеличению вероятности появления ошибок в правилах языка программирования и коде.


## Вызов методов по умолчанию

При вызове метод идентифицируется по его сигнатуре: имени и по количеству и типу параметров. Рассмотрим экземпляр класса, реализующий интерфейс с методом по умолчанию. Что случится, когда будет вызван метод для которого существует реализация по умолчанию?

> **Правило #1**
> 
> Классы выигрывают у интерфейсов. Если класс в цепочке родительских классов объявляет метод (абстрактный или конкретный), то метод по умолчанию вызван не будет.
> 
> **Правило #2**
> 
> Более специфические интерфейсы выигрывают у менее специфических («специфический» в смысле «подтип»). Метод по умолчанию из `List` выигрывает у методы по умолчанию из `Collection`, не смотря на то как и сколько раз `List` и `Collection` появляются в графе наследования.
> 
> **Правило #3**
> 
> Правило #3 отсутствует. Если в соответствии с вышеприведенными правилами нет уникального победителя, то неоднозначность должна быть устранена вручную.
> 
> <p style="text-align: right"><a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html">Brian Goetz – Mar 3 2013</a></p>

Это объясняет почему эти методы получили названия методы по умолчанию и почему они должны начинаться с ключевого слова `default`: такой метод – это всего лишь резервный метод, используемый, когда класс и не один из его родительских классов не упоминают о нем, т.е. не предоставляют реализацию и не декларируют как абстрактный метод (правило #1). Также можно сказать, что метод по умолчанию интерфейса `X` будет вызван только если класс не реализует интерфейс `Y`, который расширяет `X` и объявляет тот же самый метод (ни как метод по умолчанию, ни как абстрактный; правило #2).

И хотя эти правила довольно просты, это не предотвращает возникновение довольно сложных ситуаций. Например, предсказание [в этой статье](https://zeroturnaround.com/rebellabs/how-your-addiction-to-java-8-default-methods-may-make-pandas-sad-and-your-teammates-angry/) какой метод будет вызван является нетривиальной задачей. Поэтому данный функционал надо использовать с осторожностью.

### Разрешение конфликтов

Правило #3 означает, что класс должен предоставить свою реализацию для каждого метода у которого существуют несколько конкурирующих реализаций по умолчанию. В противном случае будет ошибка компиляции.

Если вам подходит одна из уже существующих реализаций, то вы можете [явно вызвать ее](#явный-вызов-методов-по-умолчанию) в своем коде:

```java
@Override
public String m() {
    return Interface1.super.m();
}
```

Это также означает, что добавление методов по умолчанию в интерфейсы может приводить к ошибкам компиляции. Если класс `A` реализует независимые интерфейсы `X` и `Y` и метод по умолчанию, который уже существует в `X`, добавляется в `Y`, то класс `A` перестанет компилироваться.

А что, если мы будем компилировать код по отдельности? Здесь стоит рассмотреть два случая. Допустим мы успешно скомпилировали `A`, `X` и `Y`, а затем: 

1. Добавили в `Y` объявление метода из интерфейса `X` и перекомпилировали только `Y`. В этом случае мы не сможем перекомпилировать класс `A`, но он все еще будет корректно работать.

    ![](/assets/images/posts/java-default-methods/run-but-not-compile.png)

2. Добавили в `Y` метод из интерфейса `X` со своей реализацией и перекомпилировали только `Y`. В этом случае мы не сможем перекомпилировать класс `A`, мы сможем запустить его, но в момент вызова метода `m()` мы получим ошибку времени исполнения: `IncompatibleClassChangeError`.

    ![](/assets/images/posts/java-default-methods/not-run-not-compile.png)

### Переобъявление методов как абстрактных

Если абстрактный класс или интерфейс `A` объявляют метод, который имеет реализацию по умолчанию в родительском интерфейсе `X`, абстрактным, то реализация по умолчанию считается переопределенной и все не абстрактные наследники класса `A` должны предоставить реализацию метода.

Это может быть использовано, чтобы заставить предоставить новую реализацию вместо имеющейся реализации по умолчанию, если она по каким-либо причинам не подходит. Это повсюду используется в JDK, например, `ConcurrentMap` ([ссылка](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html)) переобъявляет ряд методов, для которых `Map` ([ссылка](http://docs.oracle.com/javase/8/docs/api/java/util/Map.html)) предоставляет реализацию по умолчанию, т.к. они не потокобезопасны (поищите по фразе: «inappropriate default»).

Обратите внимание, что в таком случае нельзя [явно вызвать переопределенный метод по умолчанию](#явный-вызов-методов-по-умолчанию).

### Переопределение методов Object

В интерфейсах невозможно объявить методы из `Object` как методы по умолчанию. Это приведет к ошибке компиляции. Почему?

Прежде всего, с точки зрения вышеописанных правил, в этом нет никакого смысла. Т.к. каждый класс наследуется от `Object`, то согласно **правилу #1** интерфейсные методы никогда не будут вызваны.

Но это правило не является законом природы и экспертная группа могла сделать исключение. В письме, которое содержит вышеописанные правила, [Brian Goetz привел много причин](http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html) почему они не сделали этого. Одна из них:

> Методы класса `Object`, такие как `toString`, `equals` и `hashCode`, оперируют и описывают состояние объекта. Но интерфейсы не имеют состояния. Поэтому эти методы должны находиться в коде, который оперирует состоянием объекта, т.е. в классе.


## Зачем нужны методы по умолчанию

Теперь, когда мы знаем, как использовать методы по умолчанию, давайте попробуем разобраться зачем они были добавлены в язык.

### Эволюция интерфейсов

Экспертная группа, которая предложила методы по умолчанию, часто [утверждала](http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html):

> Цель методов по умолчанию – позволить интерфейсам эволюционировать после их публикации, не ломая обратную совместимость.

До методов по умолчанию было практически невозможным (за исключением [некоторых организационных шаблонов](http://blog.jooq.org/2013/02/01/defensive-api-evolution-with-java-interfaces/)) добавить методы в интерфейс, не сломав все его реализации. И хотя это не касается большинства разработчиков, т.к. они обычно контролируют и интерфейсы, и их реализации, для разработчиков API это очень важная проблема. Java всегда стояла на безопасной стороне и до 8-ой версии не меняла интерфейсы после их релиза.

Но с появлением лямбд придерживаться этого принципа стало невозможно. Представьте что вам всегда пришлось бы писать `Stream.of(myList).forEach(...)`, т.к. `forEach` нельзя добавить в `List`.

Поэтому экспертная группа, которая ввела лямбды, решила найти путь эволюционирования интерфейсов без ущерба для существующих реализаций. Именно это и объясняет большинство характеристик методов по умолчанию.

Методы по умолчанию позволяют не только добавлять новые методы в интерфейсы, как это сделали в JDK, но и открывает путь для рефакторинга или даже удаления существующих методов, не ломая обратную совместимость, если клиенты готовы обновить свой код в некоторой промежуточной фазе. И даже возможно сформулировать [правила для этого процесса](http://blog.codefx.org/design/patterns/interface-evolution-with-default-methods-methods/).

Методы по умолчанию могут также использоваться как [типажи](#типажи) (traits), или, скорее, нечто близкое к ним. Разработчиков JDK часто критиковали за то, что они не добавили полноценную поддержку примесей (mixins) и типажей (traits). На что они часто отвечали: «это не то чего мы хотели/хотим достичь».

### Вытеснение утилитных классов

JDK и особенно такие широко распространенные вспомогательные библиотеки, как Guava или Apache Commons, наводнены утилитными классами. Они обычно называются также, как и интерфейсы, для которых они предоставляют методы, но во множественном числе, например, `Collections` или `Sets`. Основная причина их существования заключается в том, что эти утилитные методы не могли быть добавлены в оригинальный интерфейс после его публикации. Но с методами по умолчанию это становится возможным.

Все статические методы, которые принимают сам интерфейс, теперь могут быть заменены на методы по умолчанию в самом интерфейсе. Например, статический метод `Collections.sort(List)`, начиная с Java 8 делегирует всю работу методу по умолчанию `List.sort(Comparator)`. Другой пример приведен в статье [how to use default methods to improve the decorator pattern](http://blog.codefx.org/design/patterns/decorator-pattern-java-8/). Другие утилитные методы, которые не принимают аргументов могут быть переписаны как статические методы интерфейсов.

И хотя удаление всех утилитных классов, привязанных к конкретному интерфейсу, теперь возможно, в некоторые случаях это может быть не целесообразно. Юзабилити и связность интерфейсов должны оставаться главными приоритетами. И не надо засорять интерфейсы всеми возможными методами, какие только можно придумать. Возможно имеет смысл переместить только наиболее часто используемые методы в интерфейсы, а остальные методы могут остаться в утилитных классах. (Или [удалить их совсем](http://www.yegor256.com/2014/05/05/oop-alternative-to-utility-classes.html), если вы в теме.)

### Классификация

В своей аргументации к [новым тегам для Javadoc](https://blog.codefx.org/java/new-javadoc-tags/) Brian Goetz дает следующую классификацию методов по умолчанию, которые были добавлены в SDK:

  * **Опциональные методы**

    Используются, когда реализация едва ли соответствует контракту, например, `Iterator.remove()`:

    ```java
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    ```

    Нам необходимо придерживаться контракта, но не для каждой коллекции мы можем реализовать эту операции. Однако, если можем, то мы определенно захотим сделать это и переопределим метод.

  * **Методы с разумным поведением по умолчанию, но которые могут быть переопределены при необходимости.**

    Другой пример из `Iterator`:

    ```java
    default void forEachRemaining(Consumer<? super E> action) {
        while (hasNext())
            action.accept(next());
    }
    ```

    Данная реализация подойдет в большинстве случаев, но иногда можно сделать лучше, если вы заинтересованы в этом, как например в `ArrayList`. Новые методы в интерфейсе `Map` можно отнести к этой же категории (например, `putIfAbsent`).

  * **Методы, которые практически наверняка не будут переопределены.**

    Пример из `Predicate`:

    ```java
    default Predicate<T> and(Predicate<? super T> p) {
        Objects.requireNonNull(p);
        return (T t) -> test(t) && p.test(t);
    }
    ```

Это не строгая классификация, т.к. здесь нет четких правил распределения методов по категориям. Однако это не делает ее бесполезной. Напротив, очень полезно держать эту классификацию у себя в голове при чтении и написании методов по умолчанию. Также она может помочь вам при обсуждении методов по умолчанию с коллегами.


## Наследование и проектирование классов

Часто при обсуждении методов по умолчанию возникают различные вопросы о наследовании и его использовании при проектировании классов. Давайте рассмотрим их более детально.

### Множественное наследование

При наследовании *тип* вбирает в себя характеристики другого типа. Есть три вида характеристик:
  * **тип**, т.е. *подтип* является *другим типом*
  * **поведение**, т.е. *тип* наследует методы и поэтому ведет себя также, как и *другой тип*
  * **состояние**, т.е. *тип* наследует переменные, определяющие состояние *другого типа*

В случае наследования от класса наследуются все методы и переменные этого класса, т.е. наследуются все три вида характеристик. В то же время мы можем наследоваться только от одного класса, что является существенным ограничением.

С интерфейсами другая ситуация: *тип* может наследоваться от многих интерфейсов, и он становится подтипом каждого из них. Эта часть множественного наследования поддерживалась в Java с самого первого дня.

Но до Java 8 классы наследовали от интерфейсов только тип. Да, они также наследовали и контракт, но не реализацию и должны были предоставить свое собственное поведение. Но с методами по умолчанию это изменилось, и теперь в Java поддерживается также и множественное наследование поведения.

Java все еще не предоставляет явный способ наследования состояния нескольких типов. Нечто похожее может быть достигнуто с помощью методов по умолчанию либо через [грязные хаки](http://kerflyn.wordpress.com/2012/07/09/java-8-now-you-have-mixins/), либо через [шаблон виртуальных полей](http://mail.openjdk.java.net/pipermail/lambda-dev/2012-August/005455.html). Первый очень опасен и не должен использоваться на практике, второй также имеет некоторые недостатки (особенно с точки зрения инкапсуляции) и должен использоваться с большой осторожностью.

### Методы по умолчанию vs примеси и типажи

Методы по умолчанию часто сравниваются с [примесями](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%81%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) и [типажами](https://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF%D0%B0%D0%B6_(%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF)). Данная статья не раскрывает эту тему в деталях, но дает приблизительное представление об их отличиях. (Полезное сравнение примесей и типажей можно найти на [StackOverflow](https://stackoverflow.com/questions/925609/mixins-vs-traits)).

#### Примеси

Примеси позволяют наследовать их тип, поведение и состояние. Можно наследоваться от нескольких примесей. Таким образом обеспечивается множественное наследование все трех характеристик. В некоторых языках даже возможно добавлять примеси к конкретному экземпляру во время выполнения программы.

Т.к. интерфейсы с методами по умолчанию не позволяют наследовать состояние, то определенно их нельзя назвать примесями.

#### Типажи

Подобно примесям типажи допускают наследование от нескольких типажей. Они также позволяют наследовать тип и поведение, но обычно они не имеют своего состояния. 

Это делает типажи похожими на интерфейсы с методами по умолчанию. Концептуально они различны, однако эти отличия не так просто описать. Приведем здесь лишь несколько идей в чем выражаются эти отличия:

  * Как мы уже видели, [идентификация вызываемого метода](#вызов-методов-по-умолчанию) не всегда является тривиальной задачей, что может значительно усложнить взаимодействие различных интерфейсов с методами по умолчанию. Типажи различными способами смягчают эту проблему.

  * Типажи позволяют определенные операции, которые Java поддерживает не в полной мере. См. список после фразы «selection of operations» в [этой статье](http://en.wikipedia.org/wiki/Trait_%28computer_programming%29).

  * В статье [Trait-oriented Programming in Java 8](http://dl.acm.org/citation.cfm?id=2647520) исследуется возможность использования методов по умолчания в качестве примесей и очерчивается ряд проблем такого подхода. 

Таким образом, интерфейсы с методами по умолчанию могут использоваться с некоторыми ограничениями как примеси, хотя и не являются ими.

### Методы по умолчанию vs абстрактные классы

#### Языковая разница

Давайте сначала выделим отличия на уровне языка.

И хотя интерфейсы допускают множественное наследование у них довольно много ограничений в других аспектах построения классов. Методы по умолчанию не могут быть `final`, `synchronized` и не могут переопределять методы из `Object`. В Java 8 они могут быть только публичными, что существенно препятствует написанию коротких и переиспользуемых методов. Более того, в интерфейсах мы все еще не можем определять поля и все изменения состояния должны быть выполнены через публичное API. Изменения, вносимые в API для работы с внутренним состоянием, часто ломают инкапсуляцию.

Есть ряд случаев где эти отличия не играют роли и использование обоих подходов технически возможно.

#### Концептуальная разница

В этом случае мы должны учитывать концептуальную разницу. Классы определяют: чем является объект; в то время как интерфейсы определяют: что объект может делать.

Aбстрактные классы представляют собой особый случай. [Пункт 18 из книги Effective Java](http://books.google.de/books?id=ka2VUBqHiWkC&lpg=PP1&pg=PA93#v=onepage&q&f=true) ясно объясняет почему интерфейсы превосходят абстрактные методы в определение типов с несколькими подтипами (и это даже не беря во внимание методы по умолчанию). Суть заключается в следующем: абстрактные классы подходят для частичной реализации интерфейсов (некоторой базовой логики, которая впоследствии будет уточняться) и не должны существовать без соответствующего интерфейса.

Итак, могут ли методы по умолчанию взять эту роль на себя? Решительно нет! Т.к. реализация интерфейса практически всегда требует тех инструментов построения класса, которых методы по умолчанию лишены: наличие полей (состояния), `final` и др. А если для какого-то интерфейса это не так, то это безусловно особый случай, и он не должен вводить вас в заблуждение. (Посмотрите [эту статью](http://blog.codefx.org/jdk/instances-non-capturing-lambdas/), чтобы узнать, что может случиться, когда используются методы по умолчанию.)


## Дополнительные ссылки

Интернет полон статей на данную тему:
  * [Эволюционирование интерфейсов с методами по умолчанию](http://blog.codefx.org/design/patterns/interface-evolution-with-default-methods-methods/)
  * Финальная версия [State of the Lambda](http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html) (глава 10)
  * [Официальный урок](http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html)
  * [Официальный урок о том, как интерфейсы должны развиваться](http://docs.oracle.com/javase/tutorial/java/IandI/nogrow.html)
  * [Урок на JavaCodeGeeks](http://examples.javacodegeeks.com/java-basics/java-8-default-methods-tutorial/)
  * [Урок на DZone](http://java.dzone.com/articles/interface-default-methods-java)
  * [Вопрос на StackOverflow о методах по умолчанию и примесях](http://stackoverflow.com/q/28681737/2525313)
  * [Интересный материал об ограничения методов по умолчанию](https://www.javacodegeeks.com/2014/04/java-8-default-methods-what-can-and-can-not-do.html) 


<p style="margin-top: 30px; text-align: center;">* * *</p>

Данная публикация является вольным переводом статьи [«Everything You Need To Know About Default Methods»](https://blog.codefx.org/java/everything-about-default-methods/) с некоторыми корректировками и дополнениями.
  